<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次线上Redis故障恢复和分析（二）]]></title>
    <url>%2Fposts%2F1461710894%2F</url>
    <content type="text"><![CDATA[异常场景最近一段时间时不时就有开发人员向我反应：redis的key有点问题，帮我删个key值、怎么key没有过期，我明明设了过期时间的。一开始没有放心上，以为只是程序逻辑处理不当或者redis偶尔抽风，不用在意。可是渐渐反应的人多了，觉得可能不是这么简单了，于是就和相关的开发人员讨论了下，发现会出现异常的基本是以下两种场景： 使用redis 的 incrBy 命令来防止重复提交，大致的redis交互如下： 123&gt; incrBy key 1 # 返回 1 表示正常 返回 &gt; 1 表示重复提交 直接 return&gt; expire key 5 # 5秒后过期&gt; del key # 正常业务逻辑走完后 显示删除key 使用 redis （set setnx setex ） + expire 组合命令： 12&gt; set |setnx | setex key&gt; expire key seconds # 设置失败 ​ 由于系统中大量使用了第一种方式来防止重复提交，所以这个问题对业务影响还是很大的，redis具体现象为： 设置incrby 第一次应该返回 1 实际上却返回了 2 ，导致业务流程无法走完，并且key没有删除也没有设置过期时间 查找问题编写测试程序为了排查问题写了一个简单的小程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141@Testpublic void test() throws InterruptedException &#123; final List&lt;Long&gt; list = Lists.newArrayListWithCapacity(5000000); Long first_id = 500000000000000001L; for (int i = 0; i &lt; 5000000; i++) &#123; list.add(first_id++); &#125; final CountDownLatch allDone = new CountDownLatch(2); // incrby new Thread( new Runnable() &#123; @Override public void run() &#123; try &#123; testIncrby(list); &#125; catch (InterruptedException e) &#123; &#125; allDone.countDown(); &#125; &#125; ).start(); new Thread( new Runnable() &#123; @Override public void run() &#123; try &#123; testIncrByAndDel(list); &#125; catch (InterruptedException e) &#123; &#125; allDone.countDown(); &#125; &#125; ).start(); allDone.await(); log.info("finish method test");&#125;@Testpublic void testDelAndTTL() throws InterruptedException &#123; final List&lt;Long&gt; list = Lists.newArrayListWithCapacity(5000000); Long first_id = 500000000000000001L; for (int i = 0; i &lt; 5000000; i++) &#123; list.add(first_id++); &#125; final CountDownLatch allDone = new CountDownLatch(2); new Thread( new Runnable() &#123; @Override public void run() &#123; testDelAndTTL(list, "walletMember"); allDone.countDown(); log.info("finish walletMember keys"); &#125; &#125; ).start(); new Thread( new Runnable() &#123; @Override public void run() &#123; testDelAndTTL(list, "walletMember1"); allDone.countDown(); log.info("finish walletMember1 keys"); &#125; &#125; ).start(); allDone.await(); log.info("finish all keys");&#125;private void testIncrby(final List&lt;Long&gt; list) throws InterruptedException &#123; long times = 0L; for(;;)&#123; times ++; for (Long key : list) &#123; Optional&lt;Long&gt; value = redisOperator.incrBy("walletMember" + key, 1); if (value.isPresent()) &#123; if (value.get() != 1L) &#123; log.error("there is something wrong in &#123;&#125;: the incrBy method return wrong value, expact : &#123;&#125; , result : &#123;&#125;, key : &#123;&#125;", "testIncrby", 1, value.get(), "walletMember" + key); continue; &#125; &#125; else &#123; log.error("there is something wrong in &#123;&#125;: the incrBy method return wrong value, expact : &#123;&#125; , result : &#123;&#125;, key : &#123;&#125;", "testIncrby", 1, null, "walletMember" + key); &#125; Optional&lt;Boolean&gt; isSuccess = redisOperator.expire("walletMember" + key, 30); if (!isSuccess.isPresent() || !isSuccess.get()) &#123; log.error("there is something wrong in &#123;&#125;: the expire method return wrong value, expact : &#123;&#125; , result : &#123;&#125;, key : &#123;&#125;", "testIncrby", "true", (isSuccess.isPresent() ? isSuccess.get() : null), "walletMember" + key); &#125; &#125; log.info("finish &#123;&#125; method &#123;&#125; times. sleep 35 seconds", "testIncrby", times); Thread.sleep(60*5*1000L); if(times &gt; 1000000) &#123; return ; &#125; &#125;&#125;private void testIncrByAndDel(final List&lt;Long&gt; list) throws InterruptedException &#123; long times = 0L; for(;;) &#123; times ++; for (Long key : list) &#123; Optional&lt;Long&gt; value = redisOperator.incrBy("walletMember1"+key, 1); if(value.isPresent()) &#123; if(value.get() != 1L) &#123; log.error("there is something wrong in &#123;&#125; method: the incrBy method return wrong value, expact : &#123;&#125; , result : &#123;&#125;, key : &#123;&#125;", "testIncrByAndDel", 1, value.get(), "walletMember1" + key); continue; &#125; &#125; else &#123; log.error("there is something wrong in &#123;&#125; method: the incrBy method return wrong value, expact : &#123;&#125; , result : &#123;&#125;, key : &#123;&#125;", "testIncrByAndDel", 1, null, "walletMember1" + key); &#125; Optional&lt;Boolean&gt; isSuccess= redisOperator.expire("walletMember"+key, 60); if(!isSuccess.isPresent() || !isSuccess.get()) &#123; log.error("there is something wrong in &#123;&#125;: the expire method return wrong value, expact : &#123;&#125; , result : &#123;&#125;, key : &#123;&#125;", "testIncrByAndDel", "true", (isSuccess.isPresent() ? isSuccess.get() : null), "walletMember1" + key); &#125; redisOperator.del("walletMember1"+key); &#125; log.info("finish &#123;&#125; method &#123;&#125; times. sleep 35 seconds", "testIncrByAndDel", times); Thread.sleep(60*5*1000L); if(times &gt; 1000000) &#123; return ; &#125; &#125;&#125;private void testDelAndTTL(final List&lt;Long&gt; list, String prefix) &#123; for (Long key : list) &#123; Optional&lt;Integer&gt; value = redisOperator.get(prefix + key, Integer.class); if(value.isPresent()) &#123; Long ttl = redisOperator.getFastJsonRedisTemplate().getExpire(prefix + key); log.error("there is something wrong : key : &#123;&#125;, value : &#123;&#125;, ttl : &#123;&#125;", prefix + key, value.get(), ttl); &#125; &#125;&#125; 可能是测试用例写的不好，线上线下都没有发现明显的问题，于是对代码做了调整： 12345678910111213141516171819202122232425262728293031323334353637383940@Autowired private StringRedisTemplate stringRedisTemplate; private static List&lt;String&gt; keys = Lists.newArrayListWithCapacity(100); @RequestMapping(value = "/test/redis", method = RequestMethod.POST) @ResponseBody public String createGoogleAuth() throws InterruptedException &#123; final int numThreads = 100; final ExecutorService threadPool = Executors.newFixedThreadPool(numThreads); log.info("--------------start------------------"); for(int i = 0; i &lt; 100; i++) &#123; threadPool.submit(new Runnable() &#123; @Override public void run() &#123; redis_incrby(); &#125; &#125;); &#125; return "OK"; &#125; private void redis_incrby() &#123; final int loops = 2500; String key = UUID.randomUUID().toString(); keys.add(key); for(int j=0;j&lt;loops;j++) &#123; log.info("key : &#123;&#125;, return : &#123;&#125;", key, stringRedisTemplate.opsForValue().increment(key, 1)); log.info("key : &#123;&#125;, expire : &#123;&#125;", key, stringRedisTemplate.expire(key, 5, TimeUnit.SECONDS)); log.info("key : &#123;&#125;, return : &#123;&#125;", key, stringRedisTemplate.opsForValue().increment(key, 1)); log.info("key : &#123;&#125;, expire : &#123;&#125;", key, stringRedisTemplate.expire(key, 5, TimeUnit.SECONDS)); log.info("key : &#123;&#125;, return : &#123;&#125;", key, stringRedisTemplate.opsForValue().increment(key, 1)); log.info("key : &#123;&#125;, expire : &#123;&#125;", key, stringRedisTemplate.expire(key, 5, TimeUnit.SECONDS)); log.info("key : &#123;&#125;, return : &#123;&#125;", key, stringRedisTemplate.opsForValue().increment(key, 1)); log.info("key : &#123;&#125;, expire : &#123;&#125;", key, stringRedisTemplate.expire(key, 5, TimeUnit.SECONDS)); &#125; stringRedisTemplate.delete(key); log.info("key : &#123;&#125;, finish.", key); &#125; 执行几次后终于发现了问题：按照代码逻辑，每个key最后的value应该都为10000，然后有的key的结果大于10000，于是想到两种情况： 1）客户端多发送了一次命令 2）redis 执行错误 验证原因为了验证到底是哪种原因，采取了以下方式： 修改Jedis 源码：修改BinaryClient的incrBy方法，打印日志信息： 1234public void incrBy(final byte[] key, final long integer) &#123; log.error("key: &#123;&#125;, delta : &#123;&#125;", new String(key), integer); sendCommand(INCRBY, key, toByteArray(integer));&#125; 对redis进行监听，使用watch命令： 1./redis-cli -c -h ip -p port watch 通过tcpdump 对所有流量记录进行保存 1tcpdump -i eth0 -s 0 -w tcp.cap # 保存为.cap文件可以通过wireshark 进行分析 分析原因通过重新执行上面的测试代码，对日志文件进行筛选： 1grep 10001 nohup.out 从中选取一个key：3e9dd73a-fee2-416c-b3c8-5369b2cd4ec8 然后继续筛选： 1grep "key : 3e9dd73a-fee2-416c-b3c8-5369b2cd4ec8 return : " nohup.out 仔细查看后发现： 直接从 2698 跳跃到了 2700 然后再筛选日志，发现以下内容： 连续执行了两次incrBy命令，然后再去查找同一时刻的redis watch记录，发现的确收到了两条INCRBY 3e9dd73a-fee2-416c-b3c8-5369b2cd4ec8 1命令，那接下来就要搞清楚为什么会发起两次请求，于是轮到tcpdump了。 wireshark 分析请求流量将tcpdump的文件导入wireshark后，根据筛选条件进行筛选，最终找到了对应的tcp请求（Frame 698961）： 其中这行引起了我注意：[Expert Info (Note/Sequence): This frame is a (suspected) retransmission] 查询资料后发现，这种情况是出现在以下情形： ​ 当tcp请求允许重试的前提下发现当前tcp请求过了timeout时间还没收到返回值，那么就发起一次重试，而重试的tcp请求在wireshark中就会被标记为[Expert Info (Note/Sequence): This frame is a (suspected) retransmission]。 于是原因很明显了，由于Jedis设置的超时时间过短，导致jedis发起了重试，最终导致了上述redis的异常情况。 解决方案Jedis查询jedis配置文件，发现超时时间为500毫秒， 显然太短了，遂改为15秒，改完以下重新执行了几次测试程序，都没有再发现问题，然后修改线上代码。 Redis导致上述jedis请求超时的原因也有redis cluster的原因。查询发现线上集群存在这key分布不均匀的情况： 可以看出其中一个节点的key数量是其他节点的1.5倍，并且分析这些key发现他们访问的频率也很高，在一定程度上导致了jedis的超时，因此接下来要对redis集群进行优化。]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>Jedis</tag>
        <tag>Redis Cluster</tag>
        <tag>Wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次线上Redis故障恢复和分析（一）]]></title>
    <url>%2Fposts%2F1728650486%2F</url>
    <content type="text"><![CDATA[起因那天早上一到公司就有客服过来反应我们的App登录不了了，我赶紧试了一下登陆App，发现是可以登录的，就以为是个别现象没有在意。过了一会儿客服来反应更频繁了，这才意识到可能没有那么简单。 分析一开始认为是服务器问题，检查了所有相关的应用服务器，应用是否正在运行，发现一切正常，cpu、内存、IO 都是正常的，没有异常； 然后考虑是否是代码层面问题（数据库问题被排除，因为一旦数据库出问题不可能只有一部分人受影响），于是去检查日志，发现有以下错误信息： 然后登陆redis控制台，一台一台测试，终于发现了有问题的那台机器： 接下来要做的就很简单了，redis是集群部署，并且每个节点都有master-slave，因此直接kill该节点，问题修复，一切正常。 寻找根本原因但是这样做并不能解决根本问题，由于之前部署redis集群时考虑不够周全，没有配置redis日志，因此决定直接修改配置文件，逐个重启redis节点。这也就导致了再次故障，因为那个故障节点又被启动加入集群并且由于所有节点都经历了重启该节点又被设为master了。 这时去观察该节点redis的日志，终于发现了问题，满屏都是异常信息： Can’t save in background: fork: Cannot allocate memory 通过Google得知是由于机器内存不足导致的，遂检查机器内存，发现内存已被占用超过90%，于是赶紧增大机器内存，毕竟redis 数据都是存储在内存中，才能做到这么快的读写。 基于此，对整个redis集群的内存占用情况进行了一次排查，增大了机器内存，并且增加了对机器内存使用情况的监控防止再出现此类情况。 又一个问题好景不长，一个问题解决又来一个问题，对于redis操作出现了非预期结果，类似 incrBy +1 结果+2，执行expire 结果返回失败。 该问题的跟踪解决将在下一篇文章中介绍。]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Hexo和Github Page搭建个人Blog]]></title>
    <url>%2Fposts%2F3873148614%2F</url>
    <content type="text"><![CDATA[之前使用wordpress在AWS上搭建的博客，但国内访问速度堪忧，而且费用也不少，于是觉得切到Github上，最终觉得通过Hexo和Github Page重新搭建博客，这篇文章只是为了记录搭建的过程，以防以后忘记（记性不好啊。。。） 注册域名并绑定Github Page注册Github和域名就不多说了，网上一搜一大推，接着去Github新建一个仓库，名为个人ID加 github.io，例如我的就是kitdine.github.io: 然后在该仓库下找到一个文件 CNAME， 打开后将里面的值修改为你博客的域名，例如我的 blog.jobshen.com 注册完域名后添加一条CNAME记录，然后解析到github Page的地址，我的域名是在Godaddy上注册，添加一个CNAME指向github.io，像这样： 这样你就可以通过自己的域名访问GitHub Page了。 安装Hexo之所以选择Hexo是因为Hexo看上去非常简洁而且支持Markdown，符合我的期望，安装也很方便。 准备工作Hexo 需要NodeJ.js和git Git Windows：下载并安装 git. Mac：使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core Node.js安装 Node.js 的最佳方式是使用 nvm。 cURL: 1$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget: 1$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 1$ nvm install stable 或者您也可以下载 安装程序 来安装。 Windows 用户 对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 1234567891011121314151617181920package.json&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "" &#125;, "dependencies": &#123; "hexo": "^3.0.0", "hexo-generator-archive": "^0.1.0", "hexo-generator-category": "^0.1.0", "hexo-generator-index": "^0.1.0", "hexo-generator-tag": "^0.1.0", "hexo-renderer-ejs": "^0.1.0", "hexo-renderer-stylus": "^0.2.0", "hexo-renderer-marked": "^0.2.4", "hexo-server": "^0.1.2" &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 NexT 主题Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 下载主题如果你熟悉 Git， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。 克隆最新版本 在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码： 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 启用 NexT 主题 1theme: next 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 --debug），整个命令是 hexo s --debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： 1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse 现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。 更多配置可以访问NexT获取。 写作你可以执行下列命令来创建一篇新文章。 1$ hexo new [layout] &lt;title&gt; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 布局（Layout）Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局 路径 post source/_posts page source draft source/_drafts 不要处理我的文章 如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。 文件名称Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。 变量 描述 :title 标题（小写，空格将会被替换为短杠） :year 建立的年份，比如， 2015 :month 建立的月份（有前导零），比如， 04 :i_month 建立的月份（无前导零），比如， 4 :day 建立的日期（有前导零），比如， 07 :i_day 建立的日期（无前导零），比如， 7 草稿刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。 1$ hexo publish [layout] &lt;title&gt; 草稿默认不会显示在页面中，您可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true来预览草稿。 模版（Scaffold）在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： 1$ hexo new photo &quot;My Gallery&quot; 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 生成文件修改 _config.yml 文件： 123# Directorysource_dir: sourcepublic_dir: path/to/your/github/resp # 指向本地仓库，方便提交 使用 Hexo 生成静态文件快速而且简单。 1$ hexo generate 监视文件变动Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。 1$ hexo generate --watch]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Github Page</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F1243066710%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
